/**
 * This module is generated by Emscripten with MODULARIZE=1, 
 * so the default export is a factory function returning a Promise.
 * 
 * Usage example:
 * 
 *   import createSolverModule from './solver_js.js';
 *   import type { SolverModule } from './solver.d.ts';
 * 
 *   createSolverModule().then((mod: SolverModule) => {
 *     const solver = new mod.Solver(100);
 *     ...
 *   });
 */

/**
 * The Emscripten module factory for the 'solver_js.js' code.
 * Produces an object containing all exports, including the `Solver` class.
 */
declare function createSolverModule(): Promise<SolverModule>;

/**
 * The shape of the module returned by `createSolverModule()`.
 * It exposes a `Solver` class and the vector constructors.
 */
export interface SolverModule {
  /**
   * The Solver class from the WASM build.
   */
  Solver: {
    /**
     * Constructs a new Solver with an optional LRU cache size.
     * @param exprCacheSize The maximum number of entries the expression cache can hold (default 100).
     */
    new (exprCacheSize?: number): SolverInstance;
  };

  getExceptionMessage: CallableFunction
  getException: CallableFunction

}

export interface ClassHandle {
  isAliasOf(other: ClassHandle): boolean;
  delete(): void;
  deleteLater(): this;
  isDeleted(): boolean;
  clone(): this;
}

/**
 * Represents an instance of the Solver class in JavaScript.
 * This matches the C++ methods you bound in your Embind code.
 */
export interface SolverInstance extends ClassHandle {
  /**
   * Declares a constant in the solver's symbol table.
   * @param name The name of the constant.
   * @param value The numeric value of the constant.
   */
  declareConstant(name: string, value: number): void;

  /**
   * Declares (or re-declares) a variable in the solver's symbol table.
   * @param name The name of the variable.
   * @param value The numeric value to assign to the variable.
   */
  declareVariable(name: string, value: number): void;

  /**
   * Declares a user-defined function in terms of an expression and parameter list.
   * @param name The function name (e.g. "f").
   * @param args An array of parameter names (e.g. ["x", "y"]).
   * @param expression The expression defining the function body (e.g. "x^2 + y^2").
   */
  declareFunction(name: string, args: string[], expression: string): void;

  /**
   * Evaluates a mathematical expression and returns its numeric result.
   * @param expression A string representing the mathematical expression to evaluate.
   * @param debug Whether to enable debug output (default false).
   */
  evaluate(expression: string, debug?: boolean): number;

  /**
   * Evaluates a mathematical expression for each value in a range of inputs for one variable.
   * @param variable The name of the variable (e.g. "x").
   * @param values A list of numeric values to assign to that variable.
   * @param expression The expression to evaluate (e.g. "x^2 + 1").
   * @param debug Optional debug flag.
   * @returns A plain JavaScript array of results, one per input value.
   */
  evaluateRange(variable: string, values: number[], expression: string, debug?: boolean): number[];

  /**
   * Evaluates a single expression across multiple variables, each with a range of values.
   * @param variables An array of variable names (e.g. ["x", "y"]).
   * @param valuesSets An array of arrays of numeric values for each variable.
   * @param expression The expression to evaluate (e.g. "x + y").
   * @param debug Optional debug flag.
   * @returns A flat array of results of size = product of each value set length.
   */
  evaluateRanges(variables: string[], valuesSets: number[][], expression: string, debug?: boolean): number[];

  /**
   * Clears the solver's expression cache and function cache.
   */
  clear_cache(): void;

  /**
   * Toggles whether the solver uses its LRU cache.
   * @param useCache True to enable caching, false to disable.
   */
  use_cache(useCache: boolean): void;

  /**
   * Prints expressions (postfix or inlined) for all registered functions to stdout.
   */
  print_function_expressions(): void;

  /**
   * Lists all declared constants as a JS object where keys are names and values are numbers.
   * @returns An object mapping constant names to their numeric values.
   */
  listConstants(): Record<string, number>;

  /**
   * Lists all declared variables as a JS object where keys are names and values are numbers.
   * @returns An object mapping variable names to their current numeric values.
   */
  listVariables(): Record<string, number>;

  /**
   * Sets the expression to be evaluated and parses it into a postfix representation.
   * @param expression The new expression to parse and set as current.
   * @param debug If true, prints debug info.
   */
  setCurrentExpression(expression: string, debug?: boolean): void;

  /**
   * Sets the current expression for AST-based evaluation (builds or re-builds an AST).
   * @param expression The new expression to parse and set as current.
   * @param debug If true, prints debug info.
   */
  setCurrentExpressionAST(expression: string, debug?: boolean): void;

  /**
   * Evaluates the current expression using the AST pipeline.
   * @param expression The expression to evaluate.
   * @param debug Whether to print debugging info.
   * @returns The numeric evaluation result.
   */
  evaluateAST(expression: string, debug?: boolean): number;

  /**
   * Retrieves the most recently set expression string.
   * @returns The current expression string.
   */
  getCurrentExpression(): string;

  /**
   * Efficiently generates animation data for visualizing a function.
   * @param expression The function to evaluate.
   * @param variable The variable to sweep across.
   * @param start The starting value of the variable.
   * @param end The ending value of the variable.
   * @param steps The number of steps (frames) to generate.
   * @returns An object with arrays of x and y values, e.g. { x: number[], y: number[] }.
   */
  generateAnimationData(
    expression: string,
    variable: string,
    start: number,
    end: number,
    steps: number
  ): { x: number[]; y: number[] };

  /**
   * Efficiently generates contour data for a 3D surface plot.
   * @param expression The function to evaluate.
   * @param variable1 The first variable (x-axis).
   * @param variable2 The second variable (y-axis).
   * @param start1 The start value for variable1.
   * @param end1 The end value for variable1.
   * @param steps1 The number of steps for variable1.
   * @param start2 The start value for variable2.
   * @param end2 The end value for variable2.
   * @param steps2 The number of steps for variable2.
   * @returns An object with arrays x and y, plus a matrix z, e.g. { x: number[], y: number[], z: number[][] }.
   */
  generateContourData(
    expression: string,
    variable1: string,
    variable2: string,
    start1: number,
    end1: number,
    steps1: number,
    start2: number,
    end2: number,
    steps2: number
  ): { x: number[]; y: number[]; z: number[][] };

  /**
   * Registers a predefined function (e.g., 'sin', 'cos') with a callback,
   * so that the solver recognizes it in expressions.
   * @param name The function name, e.g. 'myfunc'.
   * @param callback A JavaScript function that accepts an array of numbers and returns a number.
   * @param argCount The arity (number of arguments) for the function.
   */
  registerPredefinedFunction(
    name: string,
    callback: (args: number[]) => number,
    argCount: number
  ): void;
}

/**
 * Export the default factory function so TypeScript recognizes the usage:
 * 
 *   import createSolverModule from './solver_js.js';
 */
export default createSolverModule;
